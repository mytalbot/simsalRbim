verbose  = TRUE,
showPlot = "worth")
worth
w_errors   <- bimeval(ydata=predat, worth= worth$worth, GT=GT, simOpt=simOpt, showPlot=TRUE  )
w_errors
# Introduction of a new item with restricted measurements -----------------
# Import from a fresh file w/ Coke items
# and 1 Tie
library(simsalRbim)
dat        <- ZickeZacke
#dat        <- dat[-c(31,32),]
simOpt     <- "HoiHoiHoi"
GT         <- c(  "Huehner", "Kacke", "Zacke","Zicke" )
predat     <- bimpre (dat=dat, GT=GT, simOpt=simOpt, deviation=0, minQuantity=0)
worth      <- bimworth(ydata    = predat,
GT       = GT,
simOpt   = simOpt,
randOP   = TRUE,
intrans  = TRUE,
showPlot = "worth")
worth
w_errors   <- bimeval(ydata=predat, worth= worth$worth, GT=GT, simOpt=simOpt, filtersim=FALSE, showPlot=TRUE )
w_errors
W
ydata=predat
worth= worth$worth
GT=GT
simOpt=simOpt
showPlot=TRUE
title="Consensus Analysis"
subtitle=NULL
verbose=FALSE
filtersim=FALSE
# Helper function
printf     <- function(...) cat(sprintf(...))
predat     <- ydata
optionlist <- c(simOpt, GT)
# filter sim = TRUE; take only non randomized data
if(filtersim==TRUE){
predat     <- predat[predat$sim==FALSE, ]
}else{}
# compute the decision matrix for all data combinations in the predat object
# this has to be adapted when "side" is present in the data!
# check if side is present
if(sum(names(predat)=="sideA")==0){
# no side is present
TT <- NULL
for(i in 1:length(unique(predat$test))){
tt <- data.frame(test           = as.character(unique(predat[predat$test==unique(predat$test)[i], "test"])),
pct_first      = ifelse(predat[predat$test==unique(predat$test)[i],    ]$result== 0,
0,
sum(predat[predat$test==unique(predat$test)[i],    ]$result== 1) / length(unique(predat$subjectID))*100),
pct_second     = ifelse(predat[predat$test==unique(predat$test)[i], ]$result ==0,
0,
100 - (sum(predat[predat$test==unique(predat$test)[i], ]$result== 1) / length(unique(predat$subjectID))*100)))
TT <- rbind(TT, tt)
}
# sum(predat[predat$test==unique(predat$test)[i],    ]$result== 1) / length(unique(predat$subjectID))*100,
# # per item & then per subject test
# TT <- NULL
# for(i in 1:length(unique(predat$test))){
#
#   set    <- predat[predat$test==unique(predat$test)[i],]
#   dimset <- dim(set)[1]
#
#
#   for(j in 1:length(unique(set$subjectID))){
#
#    if((set[set$subjectID == unique(set$subjectID[j]), "quantityA" ] +
#        set[set$subjectID == unique(set$subjectID[j]), "quantityB" ])==0){
#
#      pfirst  <- 0
#      psecond <- 0
#
#    }else{
#
#      if(set[set$subjectID == unique(set$subjectID[j]), "result" ]==1){
#
#        pfirst  <- sum(set[set$subjectID == unique(set$subjectID[j]), "result" ]== 1) /dimset
#        psecond <- 1-pfirst
#
#      }else{
#        psecond  <- sum(set[set$subjectID == unique(set$subjectID[j]), "result" ]==-1) /dimset
#        pfirst   <- 1-psecond
#      }
#    }
#
#     tt <- data.frame(test           = as.character(unique(predat[predat$test==unique(predat$test)[i], "test"])),
#                      pct_first      = pfirst*100,
#                      pct_second     = psecond*100)
#     TT <- rbind(TT, tt)
#
#   }
#
# }
#
# side is present
}else{
if(verbose==TRUE){
printf ( "simsalRbim: sideA outcomes were averaged\n")
}else{}
TT <- NULL
for (i in 1:length(unique(predat$test))){
test           = as.character(unique(predat[predat$test==unique(predat$test)[i], "test"]))
# Side A
seldat      = predat[predat$test==test, ]
no_side <- NULL
tt      <- NULL
AA      <- NULL
leer    <- NULL
for(j in 1:length(unique(seldat$subjectID))){
AA      <- NULL
leer    <- NULL
AA              <- seldat[seldat$subjectID %in% unique(seldat$subjectID)[j],]
leer            <- seldat[seldat$subjectID %in% unique(seldat$subjectID)[j],][1,]
leer$quantityA  <- mean(AA$quantityA, na.rm=TRUE)
leer$quantityB  <- mean(AA$quantityB, na.rm=TRUE)
leer$qPercentA  <- leer$quantityA / (leer$quantityA +leer$quantityB) *100
leer$qPercentB  <- leer$quantityB / (leer$quantityA +leer$quantityB) *100
leer$result     <- ifelse(leer$quantityA > leer$quantityB, 1,-1)
no_side         <- rbind(no_side, leer)
}
no_side[,"sideA"] <- NULL
tt <- data.frame(test           = test,
pct_first      = sum(no_side$result== 1) / length(unique(no_side$subjectID))*100,
pct_second     = ifelse(no_side[no_side$test %in% unique(no_side$test), ]$result ==0,
0,
100 - (sum(no_side[no_side$test %in% unique(no_side$test), ]$result== 1) / length(unique(no_side$subjectID))*100)))
TT <- rbind(TT, tt)
}
}
# 1. CE bestimmen und 2. wie viel weichen ab?
# check subjects data coverage - results may be underrepresented!
BB        <- predat[grepl(simOpt,predat$test, fixed = TRUE),  ]
provided  <- length(unique(BB$subjectID [BB$sim == FALSE   ]))
simulated <- length( unique(BB$subjectID[BB$sim != FALSE   ]) )
subjratio <- provided/ (simulated + provided)
# item coverage
II              <- predat[grepl(simOpt, predat$test, fixed = TRUE),]
items_provided  <- length(unique(II$test [II$sim == FALSE   ]))
items_simulated <- length(unique(II$test [II$sim != FALSE   ]))
itemratio       <- items_provided/(items_simulated + items_provided)
# warning: too few subjects
if((subjratio)<coverage){
warning(paste("simsalRbim: ","No. of SUBJECTS WARNING!
The number of subjects you have provided for testing the
simOpt=", "'", simOpt,"'" ," item is probably insufficient!
Try increasing the number of subjects.
You are currently below ", coverage*100, "% data coverage for
that item.
The consensus error may be biased!
Your provided-to-simulated subjects ratio is at: ",
round(subjratio,4) * 100, "%.\n", sep=""))
}else{}
# warning if too few item combinations
if((itemratio)<coverage){
warning(paste("simsalRbim: ","No. of ITEMS WARNING!
The number of item tests you have provided for testing the
simOpt=", "'", simOpt,"'" ," item is probably insufficient!
Try increasing the number of item combinations.
You are currently below ", coverage*100, "% item coverage for
that item.
The consensus error may be biased!
Your provided-to-simulated items ratio is at: ",
round(itemratio,4) * 100, "%.\n", sep=""))
}else{}
# calculate the mean deviation weights
weights        <- NULL
# no_of_subjects <- max( length( unique(predat$subjectID)), na.rm=TRUE ) # max!
for(j in 1:length(optionlist)){
item  <- TT[grepl(optionlist[j], TT$test, fixed = TRUE),]
liste <- NULL
for(i in 1:dim(item)[1]){
if( item[i, "pct_first" ] > item[i, "pct_second" ]  ){
delta  <- (50 - item[i, "pct_second" ])
}else{
delta  <- (50 - item[i, "pct_first" ])
}
liste    <- rbind(liste, data.frame(item =optionlist[j], delta = delta))
}
mean_delta <- mean(liste$delta) # describes the consensus (50 is best!)
sd_delta   <- sd  (liste$delta, na.rm = TRUE)
n_delta    <- length(liste$delta)
lwr        <- mean_delta - qt(0.975,df=length(liste$delta)-1)*sd  (liste$delta, na.rm = TRUE)/sqrt(length(liste$delta))
upr        <- mean_delta + qt(0.975,df=length(liste$delta)-1)*sd  (liste$delta, na.rm = TRUE)/sqrt(length(liste$delta))
weights    <- rbind(weights, data.frame(item       = optionlist[j],
mean_delta = mean_delta))#,
#sd_delta   = sd_delta,
#n          = n_delta,
#lwr        = lwr,
#upr        = upr ))
}
weights.sorted <- weights[order(rownames(weights)),]
W              <- cbind(weights.sorted ,
worth = worth[match(weights.sorted$item, rownames(worth)),])
#W <- label <- NULL
W$CE           <- round((50-W$mean_delta)/50*100,2) # consensus error!
W$label        <- paste(W$item," ", round((50-W$mean_delta)/50*100,2), "%",sep="")
coverage=0.8
# Helper function
printf     <- function(...) cat(sprintf(...))
predat     <- ydata
optionlist <- c(simOpt, GT)
# filter sim = TRUE; take only non randomized data
if(filtersim==TRUE){
predat     <- predat[predat$sim==FALSE, ]
}else{}
# compute the decision matrix for all data combinations in the predat object
# this has to be adapted when "side" is present in the data!
# check if side is present
if(sum(names(predat)=="sideA")==0){
# no side is present
TT <- NULL
for(i in 1:length(unique(predat$test))){
tt <- data.frame(test           = as.character(unique(predat[predat$test==unique(predat$test)[i], "test"])),
pct_first      = ifelse(predat[predat$test==unique(predat$test)[i],    ]$result== 0,
0,
sum(predat[predat$test==unique(predat$test)[i],    ]$result== 1) / length(unique(predat$subjectID))*100),
pct_second     = ifelse(predat[predat$test==unique(predat$test)[i], ]$result ==0,
0,
100 - (sum(predat[predat$test==unique(predat$test)[i], ]$result== 1) / length(unique(predat$subjectID))*100)))
TT <- rbind(TT, tt)
}
# sum(predat[predat$test==unique(predat$test)[i],    ]$result== 1) / length(unique(predat$subjectID))*100,
# # per item & then per subject test
# TT <- NULL
# for(i in 1:length(unique(predat$test))){
#
#   set    <- predat[predat$test==unique(predat$test)[i],]
#   dimset <- dim(set)[1]
#
#
#   for(j in 1:length(unique(set$subjectID))){
#
#    if((set[set$subjectID == unique(set$subjectID[j]), "quantityA" ] +
#        set[set$subjectID == unique(set$subjectID[j]), "quantityB" ])==0){
#
#      pfirst  <- 0
#      psecond <- 0
#
#    }else{
#
#      if(set[set$subjectID == unique(set$subjectID[j]), "result" ]==1){
#
#        pfirst  <- sum(set[set$subjectID == unique(set$subjectID[j]), "result" ]== 1) /dimset
#        psecond <- 1-pfirst
#
#      }else{
#        psecond  <- sum(set[set$subjectID == unique(set$subjectID[j]), "result" ]==-1) /dimset
#        pfirst   <- 1-psecond
#      }
#    }
#
#     tt <- data.frame(test           = as.character(unique(predat[predat$test==unique(predat$test)[i], "test"])),
#                      pct_first      = pfirst*100,
#                      pct_second     = psecond*100)
#     TT <- rbind(TT, tt)
#
#   }
#
# }
#
# side is present
}else{
if(verbose==TRUE){
printf ( "simsalRbim: sideA outcomes were averaged\n")
}else{}
TT <- NULL
for (i in 1:length(unique(predat$test))){
test           = as.character(unique(predat[predat$test==unique(predat$test)[i], "test"]))
# Side A
seldat      = predat[predat$test==test, ]
no_side <- NULL
tt      <- NULL
AA      <- NULL
leer    <- NULL
for(j in 1:length(unique(seldat$subjectID))){
AA      <- NULL
leer    <- NULL
AA              <- seldat[seldat$subjectID %in% unique(seldat$subjectID)[j],]
leer            <- seldat[seldat$subjectID %in% unique(seldat$subjectID)[j],][1,]
leer$quantityA  <- mean(AA$quantityA, na.rm=TRUE)
leer$quantityB  <- mean(AA$quantityB, na.rm=TRUE)
leer$qPercentA  <- leer$quantityA / (leer$quantityA +leer$quantityB) *100
leer$qPercentB  <- leer$quantityB / (leer$quantityA +leer$quantityB) *100
leer$result     <- ifelse(leer$quantityA > leer$quantityB, 1,-1)
no_side         <- rbind(no_side, leer)
}
no_side[,"sideA"] <- NULL
tt <- data.frame(test           = test,
pct_first      = sum(no_side$result== 1) / length(unique(no_side$subjectID))*100,
pct_second     = ifelse(no_side[no_side$test %in% unique(no_side$test), ]$result ==0,
0,
100 - (sum(no_side[no_side$test %in% unique(no_side$test), ]$result== 1) / length(unique(no_side$subjectID))*100)))
TT <- rbind(TT, tt)
}
}
# 1. CE bestimmen und 2. wie viel weichen ab?
# check subjects data coverage - results may be underrepresented!
BB        <- predat[grepl(simOpt,predat$test, fixed = TRUE),  ]
provided  <- length(unique(BB$subjectID [BB$sim == FALSE   ]))
simulated <- length( unique(BB$subjectID[BB$sim != FALSE   ]) )
subjratio <- provided/ (simulated + provided)
# item coverage
II              <- predat[grepl(simOpt, predat$test, fixed = TRUE),]
items_provided  <- length(unique(II$test [II$sim == FALSE   ]))
items_simulated <- length(unique(II$test [II$sim != FALSE   ]))
itemratio       <- items_provided/(items_simulated + items_provided)
# warning: too few subjects
if((subjratio)<coverage){
warning(paste("simsalRbim: ","No. of SUBJECTS WARNING!
The number of subjects you have provided for testing the
simOpt=", "'", simOpt,"'" ," item is probably insufficient!
Try increasing the number of subjects.
You are currently below ", coverage*100, "% data coverage for
that item.
The consensus error may be biased!
Your provided-to-simulated subjects ratio is at: ",
round(subjratio,4) * 100, "%.\n", sep=""))
}else{}
# warning if too few item combinations
if((itemratio)<coverage){
warning(paste("simsalRbim: ","No. of ITEMS WARNING!
The number of item tests you have provided for testing the
simOpt=", "'", simOpt,"'" ," item is probably insufficient!
Try increasing the number of item combinations.
You are currently below ", coverage*100, "% item coverage for
that item.
The consensus error may be biased!
Your provided-to-simulated items ratio is at: ",
round(itemratio,4) * 100, "%.\n", sep=""))
}else{}
# calculate the mean deviation weights
weights        <- NULL
# no_of_subjects <- max( length( unique(predat$subjectID)), na.rm=TRUE ) # max!
for(j in 1:length(optionlist)){
item  <- TT[grepl(optionlist[j], TT$test, fixed = TRUE),]
liste <- NULL
for(i in 1:dim(item)[1]){
if( item[i, "pct_first" ] > item[i, "pct_second" ]  ){
delta  <- (50 - item[i, "pct_second" ])
}else{
delta  <- (50 - item[i, "pct_first" ])
}
liste    <- rbind(liste, data.frame(item =optionlist[j], delta = delta))
}
mean_delta <- mean(liste$delta) # describes the consensus (50 is best!)
sd_delta   <- sd  (liste$delta, na.rm = TRUE)
n_delta    <- length(liste$delta)
lwr        <- mean_delta - qt(0.975,df=length(liste$delta)-1)*sd  (liste$delta, na.rm = TRUE)/sqrt(length(liste$delta))
upr        <- mean_delta + qt(0.975,df=length(liste$delta)-1)*sd  (liste$delta, na.rm = TRUE)/sqrt(length(liste$delta))
weights    <- rbind(weights, data.frame(item       = optionlist[j],
mean_delta = mean_delta))#,
#sd_delta   = sd_delta,
#n          = n_delta,
#lwr        = lwr,
#upr        = upr ))
}
weights.sorted <- weights[order(rownames(weights)),]
W              <- cbind(weights.sorted ,
worth = worth[match(weights.sorted$item, rownames(worth)),])
#W <- label <- NULL
W$CE           <- round((50-W$mean_delta)/50*100,2) # consensus error!
W$label        <- paste(W$item," ", round((50-W$mean_delta)/50*100,2), "%",sep="")
W
mean_delta
W
simOpt     <- "second_plane"
GT         <- c("mouseswing", "clip_papertube",  "rope", "clip_plastictube")
predat     <- bimpre (dat=data, GT=GT, simOpt=simOpt, deviation=0, minQuantity=0)
worth      <- bimworth(ydata    = predat,
GT       = GT,
simOpt   = simOpt,
intrans  = TRUE,
verbose  = TRUE,
showPlot = "worth")
worth
w_errors   <- bimeval(ydata=predat, worth= worth$worth, GT=GT, simOpt=simOpt, showPlot=TRUE  )
w_errors
simOpt     <- "second_plane"
GT         <- c("mouseswing", "clip_papertube",  "rope", "clip_plastictube")
predat     <- bimpre (dat=data, GT=GT, simOpt=simOpt, deviation=0, minQuantity=0)
worth      <- bimworth(ydata    = predat,
GT       = GT,
simOpt   = simOpt,
intrans  = TRUE,
verbose  = TRUE,
showPlot = "worth")
worth
w_errors   <- bimeval(ydata=predat, worth= worth$worth, GT=GT, simOpt=simOpt, showPlot=TRUE  )
w_errors
worth
ydata=predat
worth= worth$worth
GT=GT
simOpt=simOpt
coverage=0.8
showPlot=FALSE
filtersim=FALSE
title="Consensus Analysis"
subtitle=NULL
verbose=FALSE
ylim=c(0,1)
# Helper function
printf     <- function(...) cat(sprintf(...))
predat     <- ydata
optionlist <- c(simOpt, GT)
# filter sim = TRUE; take only non randomized data
if(filtersim==TRUE){
predat     <- predat[predat$sim==FALSE, ]
}else{}
predat
# no side is present
TT <- NULL
for(i in 1:length(unique(predat$test))){
tt <- data.frame(test           = as.character(unique(predat[predat$test==unique(predat$test)[i], "test"])),
pct_first      = ifelse(predat[predat$test==unique(predat$test)[i],    ]$result== 0,
0,
sum(predat[predat$test==unique(predat$test)[i],    ]$result== 1) / length(unique(predat$subjectID))*100),
pct_second     = ifelse(predat[predat$test==unique(predat$test)[i], ]$result ==0,
0,
100 - (sum(predat[predat$test==unique(predat$test)[i], ]$result== 1) / length(unique(predat$subjectID))*100)))
TT <- rbind(TT, tt)
}
TT
# tcut <- fval umbennenen!!!
library(simsalRbim)
#  Perfect use case with no randomized items ------------------------------
dat        <- bimload("C:/MHH Bleich/Aktuelles/PrePrefPackage 2020/data/ZickeZackelinear.txt")
# dat <- dat[dat$subjectID=="eins", ]
simOpt     <- "Zicke"
GT         <- c("Zacke", "Huehner", "Kacke" )
predat     <- bimpre (dat=dat, GT=GT, simOpt=simOpt, deviation=0, minQuantity=0)
worth      <- bimworth(ydata    = predat,
GT       = GT,
simOpt   = simOpt,
intrans  = TRUE,
verbose  = TRUE,
showPlot = "worth")
worth
w_errors   <- bimeval(ydata=predat, worth= worth$worth, GT=GT, simOpt=simOpt, showPlot=TRUE  )
w_errors
dat
dat        <- bimload("C:/MHH Bleich/Aktuelles/PrePrefPackage 2020/data/ZickeZackelinear.txt")
dat[24,"quantityA" ] <- 1
dat[24,"quantityB" ] <- 8
dat
# dat <- dat[dat$subjectID=="eins", ]
simOpt     <- "Zicke"
GT         <- c("Zacke", "Huehner", "Kacke" )
predat     <- bimpre (dat=dat, GT=GT, simOpt=simOpt, deviation=0, minQuantity=0)
worth      <- bimworth(ydata    = predat,
GT       = GT,
simOpt   = simOpt,
intrans  = TRUE,
verbose  = TRUE,
showPlot = "worth")
worth
w_errors   <- bimeval(ydata=predat, worth= worth$worth, GT=GT, simOpt=simOpt, showPlot=TRUE  )
w_errors
dat
75+75+75+25/4
(75+75+75+25)/4
ydata=predat
worth= worth$worth
GT=GT
simOpt=simOpt
coverage=0.8
showPlot=FALSE
filtersim=FALSE
title="Consensus Analysis"
subtitle=NULL
verbose=FALSE
ylim=c(0,1)
# Helper function
printf     <- function(...) cat(sprintf(...))
predat     <- ydata
optionlist <- c(simOpt, GT)
# filter sim = TRUE; take only non randomized data
if(filtersim==TRUE){
predat     <- predat[predat$sim==FALSE, ]
}else{}
# no side is present
TT <- NULL
for(i in 1:length(unique(predat$test))){
tt <- data.frame(test           = as.character(unique(predat[predat$test==unique(predat$test)[i], "test"])),
pct_first      = ifelse(predat[predat$test==unique(predat$test)[i],    ]$result== 0,
0,
sum(predat[predat$test==unique(predat$test)[i],    ]$result== 1) / length(unique(predat$subjectID))*100),
pct_second     = ifelse(predat[predat$test==unique(predat$test)[i], ]$result ==0,
0,
100 - (sum(predat[predat$test==unique(predat$test)[i], ]$result== 1) / length(unique(predat$subjectID))*100)))
TT <- rbind(TT, tt)
}
TT
predat[predat$test==unique(predat$test)[i],    ]$result== 0
predat[predat$test==unique(predat$test)[i],    ]$result== 1
sum(predat[predat$test==unique(predat$test)[i],    ]$result== 1) / length(unique(predat$subjectID))*100)
sum(predat[predat$test==unique(predat$test)[i],    ]$result== 1) / length(unique(predat$subjectID))*100
i=2
as.character(unique(predat[predat$test==unique(predat$test)[i], "test"]))
ifelse(predat[predat$test==unique(predat$test)[i],    ]$result== 0,
0,
sum(predat[predat$test==unique(predat$test)[i],    ]$result== 1) / length(unique(predat$subjectID))*100)
predat
predat[predat$test==unique(predat$test)[i],    ]$result== 1
sum(predat[predat$test==unique(predat$test)[i],    ]$result== 1)
sum(predat[predat$test==unique(predat$test)[i],    ]$result== 1) / length(unique(predat$subjectID))*100)
sum(predat[predat$test==unique(predat$test)[i],    ]$result== 1) / length(unique(predat$subjectID))*100
predat[predat$test==unique(predat$test)[i],    ]$result== 1) / length(unique(predat$subjectID))*100
sum(predat[predat$test==unique(predat$test)[i],    ]$result== 1)
predat[predat$test==unique(predat$test)[i],    ]$result
