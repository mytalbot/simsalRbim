w_errors   <- bimeval(ydata=predat, worth= worth$worth, GT=GT, simOpt=simOpt )
w_errors
# Import from a fresh file w/ Coke items
# and 1 Tie
dat        <- ZickeZacke
simOpt     <- "HoiHoiHoi"
GT         <- c( "Huehner", "Kacke",  "Zicke","Zacke" )
predat     <- bimpre (dat=dat, GT=GT, simOpt=simOpt, deviation=0, minQuantity=0)
worth      <- bimworth(ydata    = predat,
GT       = GT,
simOpt   = simOpt,
randOP   = TRUE,
intrans  = TRUE,
showPlot = "worth")
worth
w_errors   <- bimeval(ydata=predat, worth= worth$worth, GT=GT, simOpt=simOpt )
w_errors
dat
library(simsalRbim)
# Introduction of a new item with restricted measurements -----------------
# Import from a fresh file w/ Coke items
# and 1 Tie
dat        <- ZickeZacke
simOpt     <- "HoiHoiHoi"
GT         <- c( "Huehner", "Kacke",  "Zicke","Zacke" )
predat     <- bimpre (dat=dat, GT=GT, simOpt=simOpt, deviation=0, minQuantity=0)
worth      <- bimworth(ydata    = predat,
GT       = GT,
simOpt   = simOpt,
randOP   = TRUE,
intrans  = TRUE,
showPlot = "worth")
worth
w_errors   <- bimeval(ydata=predat, worth= worth$worth, GT=GT, simOpt=simOpt )
w_errors
25+25
50/4
50+50+50+25
/4
175/4
50-43.75
6.25/50*100
50-(50/4)/50*100
length(unique(predat$subjectID))
library(simsalRbim)
ydata=predat
# Introduction of a new item with restricted measurements -----------------
# Import from a fresh file w/ Coke items
# and 1 Tie
dat        <- ZickeZacke
simOpt     <- "HoiHoiHoi"
GT         <- c( "Huehner", "Kacke",  "Zicke","Zacke" )
predat     <- bimpre (dat=dat, GT=GT, simOpt=simOpt, deviation=0, minQuantity=0)
worth      <- bimworth(ydata    = predat,
GT       = GT,
simOpt   = simOpt,
randOP   = TRUE,
intrans  = TRUE,
showPlot = "worth")
worth
ydata=predat
worth= worth$worth
predat     <- ydata
optionlist <- c(simOpt, GT)
# filter sim = TRUE; take only non randomized data
if(filtersim==TRUE){
predat     <- predat[predat$sim==FALSE, ]
}else{}
filtersim=TRUE
# filter sim = TRUE; take only non randomized data
if(filtersim==TRUE){
predat     <- predat[predat$sim==FALSE, ]
}else{}
# compute the decision matrix for all data combinations in the predat object
TT <- NULL
for(i in 1:length(unique(predat$test))){
tt <- data.frame(test   = as.character(unique(predat[predat$test==unique(predat$test)[i], "test"])),
pct_first      = sum(predat[predat$test==unique(predat$test)[i], ]$result== 1) / length(unique(predat$subjectID))*100,
pct_second     = 100 - (sum(predat[predat$test==unique(predat$test)[i], ]$result== 1) / length(unique(predat$subjectID))*100))
TT <- rbind(TT, tt)
}
# check subjects data coverage - results may be underrepresented!
BB        <- predat[grepl(simOpt,predat$test, fixed = TRUE),  ]
provided  <- length(unique(BB$subjectID[BB$tie == FALSE   ]))
simulated <- length(unique(BB$subjectID[BB$tie != FALSE   ]))
subjratio <- provided/(simulated + provided)
# item coverage
II              <- predat[grepl(simOpt, predat$test, fixed = TRUE),]
items_provided  <- length(unique(II$test [II$tie == FALSE   ]))
items_simulated <- length(unique(II$test [II$tie != FALSE   ]))
itemratio       <- items_provided/(items_simulated + items_provided)
# warning: too few subjects
if((subjratio)<coverage){
warning(paste("simsalRbim: ","No. of SUBJECTS WARNING!
The number of subjects you have provided for testing the simOpt=", "'", simOpt,"'" ," item is probably insufficient!
Try increasing the number of subjects.
You are currently below ", coverage*100, "% data coverage for that item.
Your provided-to-simulated subjects ratio is at: ",
round(subjratio,4) * 100, "%.\n", sep=""))
}else{}
# warning if too few item combinations
if((itemratio)<coverage){
warning(paste("simsalRbim: ","No. of ITEMS WARNING!
The number of item tests you have provided for testing the simOpt=", "'", simOpt,"'" ," item is probably insufficient!
Try increasing the number of item combinations.
You are currently below ", coverage*100, "% item coverage for that item.
Your provided-to-simulated items ratio is at: ",
round(itemratio,4) * 100, "%.\n", sep=""))
}else{}
coverage=0.8
# warning: too few subjects
if((subjratio)<coverage){
warning(paste("simsalRbim: ","No. of SUBJECTS WARNING!
The number of subjects you have provided for testing the simOpt=", "'", simOpt,"'" ," item is probably insufficient!
Try increasing the number of subjects.
You are currently below ", coverage*100, "% data coverage for that item.
Your provided-to-simulated subjects ratio is at: ",
round(subjratio,4) * 100, "%.\n", sep=""))
}else{}
# warning if too few item combinations
if((itemratio)<coverage){
warning(paste("simsalRbim: ","No. of ITEMS WARNING!
The number of item tests you have provided for testing the simOpt=", "'", simOpt,"'" ," item is probably insufficient!
Try increasing the number of item combinations.
You are currently below ", coverage*100, "% item coverage for that item.
Your provided-to-simulated items ratio is at: ",
round(itemratio,4) * 100, "%.\n", sep=""))
}else{}
# calculate the mean deviation weights
weights    <- NULL
for(j in 1:length(optionlist)){
item  <- TT[grepl(optionlist[j], TT$test, fixed = TRUE),]
liste <- NULL
for(i in 1:dim(item)[1]){
if( item[i, "pct_first" ] > item[i, "pct_second" ]  ){
delta  <- (50 - item[i, "pct_second" ])
}else{
delta  <- (50 - item[i, "pct_first" ])
}
liste    <- rbind(liste, data.frame(item =optionlist[j], delta = delta))
}
liste
for(j in 1:length(optionlist)){
item  <- TT[grepl(optionlist[j], TT$test, fixed = TRUE),]
liste <- NULL
for(i in 1:dim(item)[1]){
if( item[i, "pct_first" ] > item[i, "pct_second" ]  ){
delta  <- (50 - item[i, "pct_second" ])
}else{
delta  <- (50 - item[i, "pct_first" ])
}
liste    <- rbind(liste, data.frame(item =optionlist[j], delta = delta))
}
item  <- TT[grepl(optionlist[j], TT$test, fixed = TRUE),]
liste <- NULL
for(i in 1:dim(item)[1]){
if( item[i, "pct_first" ] > item[i, "pct_second" ]  ){
delta  <- (50 - item[i, "pct_second" ])
}else{
delta  <- (50 - item[i, "pct_first" ])
}
liste    <- rbind(liste, data.frame(item =optionlist[j], delta = delta))
}
j=1
item  <- TT[grepl(optionlist[j], TT$test, fixed = TRUE),]
liste <- NULL
for(i in 1:dim(item)[1]){
if( item[i, "pct_first" ] > item[i, "pct_second" ]  ){
delta  <- (50 - item[i, "pct_second" ])
}else{
delta  <- (50 - item[i, "pct_first" ])
}
liste    <- rbind(liste, data.frame(item =optionlist[j], delta = delta))
}
liste
length(unique(predat$subjectID))
max(unique(predat$subjectID), na.rm=TRUE)
unique(predat$subjectID)
max( length( unique(predat$subjectID)), na.rm=TRUE )
library(simsalRbim)
library(simsalRbim)
#  Perfect use case with no randomized items ------------------------------
dat        <- bimload("C:/MHH Bleich/Aktuelles/PrePrefPackage 2020/data/ZickeZackelinear.txt")
# dat <- dat[dat$subjectID=="eins", ]
simOpt     <- "Zicke"
GT         <- c("Zacke", "Huehner", "Kacke" )
predat     <- bimpre (dat=dat, GT=GT, simOpt=simOpt, deviation=0, minQuantity=0)
worth      <- bimworth(ydata    = predat,
GT       = GT,
simOpt   = simOpt,
intrans  = TRUE,
verbose  = TRUE,
showPlot = "worth")
worth
w_errors   <- bimeval(ydata=predat, worth= worth$worth, GT=GT, simOpt=simOpt )
w_errors
library(simsalRbim)
library(simsalRbim)
#  Perfect use case with no randomized items ------------------------------
dat        <- bimload("C:/MHH Bleich/Aktuelles/PrePrefPackage 2020/data/ZickeZackelinear.txt")
# dat <- dat[dat$subjectID=="eins", ]
simOpt     <- "Zicke"
GT         <- c("Zacke", "Huehner", "Kacke" )
predat     <- bimpre (dat=dat, GT=GT, simOpt=simOpt, deviation=0, minQuantity=0)
worth      <- bimworth(ydata    = predat,
GT       = GT,
simOpt   = simOpt,
intrans  = TRUE,
verbose  = TRUE,
showPlot = "worth")
worth
w_errors   <- bimeval(ydata=predat, worth= worth$worth, GT=GT, simOpt=simOpt )
w_errors
# Introduction of a new item with restricted measurements -----------------
# Import from a fresh file w/ Coke items
# and 1 Tie
dat        <- ZickeZacke
simOpt     <- "HoiHoiHoi"
GT         <- c( "Huehner", "Kacke",  "Zicke","Zacke" )
predat     <- bimpre (dat=dat, GT=GT, simOpt=simOpt, deviation=0, minQuantity=0)
worth      <- bimworth(ydata    = predat,
GT       = GT,
simOpt   = simOpt,
randOP   = TRUE,
intrans  = TRUE,
showPlot = "worth")
worth
w_errors   <- bimeval(ydata=predat, worth= worth$worth, GT=GT, simOpt=simOpt )
w_errors
dat
dat
w_errors   <- bimeval(ydata=predat, worth= worth$worth, GT=GT, simOpt=simOpt )
w_errors
w_errors   <- bimeval(ydata=predat, worth= worth$worth, GT=GT, simOpt=simOpt )
w_errors
library(simsalRbim)
w_errors   <- bimeval(ydata=predat, worth= worth$worth, GT=GT, simOpt=simOpt )
w_errors
### Now we do an uninformed item positioning, also to obtain a reasonable threshold for the no. of randomizations
cutoff     <- bimUninformed(ydata=predat, GT=GT, simOpt=simOpt, limitToRun=100, ylim=c(-0.6,1.1) )
cutoff$cutoff
# Human data 1 --------------------------------------------------------------
dat        <- bimload ("C:/MHH Bleich/Aktuelles/PrePrefPackage 2020/data/human_LagreValenceRange_SpringSchool.txt")
simOpt     <- "Lake"
GT         <- c("Frustrated","Crow","War","Cat","Doctor", "Fire")
predat     <- bimpre (dat=dat, GT=GT, simOpt=simOpt, deviation=0, minQuantity=0)
worth      <- bimworth(ydata    = predat,
GT       = GT,
simOpt   = simOpt,
intrans  = TRUE,
showPlot = "est")
worth
w_errors   <- bimeval(ydata=predat, worth= worth$worth, GT=GT, simOpt=simOpt )
w_errors
dat        <- bimload ("C:/MHH Bleich/Aktuelles/PrePrefPackage 2020/data/human_LowValenceRange.txt")
simOpt     <- "Sunset"
GT         <- c("House","Grass","Food","Monkey","Timber","Flowers" )
predat     <- bimpre (dat=dat, GT=GT, simOpt=simOpt, deviation=0, minQuantity=0)
worth      <- bimworth(ydata    = predat,
GT       = GT,
simOpt   = simOpt,
intrans  = TRUE,
showPlot = "est")
worth
w_errors   <- bimeval(ydata=predat, worth= worth$worth, GT=GT, simOpt=simOpt )
w_errors
dat        <- bimload ("C:/MHH Bleich/Aktuelles/PrePrefPackage 2020/data/human_LargeValanceRange.txt")
simOpt     <- "Lake"
GT         <- c("Crow","War","Cat","Doctor", "Fire", "Frustrated")
predat     <- bimpre (dat=dat, GT=GT, simOpt=simOpt, deviation=0, minQuantity=0)
worth      <- bimworth(ydata    = predat,
GT       = GT,
simOpt   = simOpt,
intrans  = TRUE,
randOP   = TRUE,
showPlot = "est")
worth
w_errors   <- bimeval(ydata=predat, worth= worth$worth, GT=GT, simOpt=simOpt )
w_errors
# Human data test------------------------------------------------------------
# Introduction of the Nackmull
dat        <- bimload ("C:/MHH Bleich/Aktuelles/PrePrefPackage 2020/data/human_LagreValenceRange_SpringSchool.txt")
dat        <- rbind(dat, data.frame(subjectID = c("16de27e0","16de27e0","1cdf6341","36f1fbb9"),
optionA   = c("Lake","Doctor","Frustrated","Crow"),
optionB   = c("Nacktmull","Nacktmull","Nacktmull", "Nacktmull"),
quantityA = c(220,190,50,120),
quantityB = c(40,170,22,114),
sideA     = c("left", "left", "left", "left")))
simOpt     <- "Nacktmull"
GT         <- c("Lake","Crow","War","Cat","Doctor", "Fire", "Frustrated")
predat     <- bimpre (dat=dat, GT=GT, simOpt=simOpt, deviation=0, minQuantity=0)
worth      <- bimworth(ydata    = predat,
GT       = GT,
simOpt   = simOpt,
intrans  = TRUE ,
showPlot = TRUE)
worth
w_errors   <- bimeval(ydata=predat, worth= worth$worth, GT=GT, simOpt=simOpt )
w_errors
w_errors   <- bimeval(ydata=predat, worth= worth$worth, GT=GT, simOpt=simOpt )
w_errors
# Introduction of a new item with restricted measurements -----------------
# Import from a fresh file w/ Coke items
# and 1 Tie
dat        <- ZickeZacke
simOpt     <- "HoiHoiHoi"
GT         <- c( "Huehner", "Kacke",  "Zicke","Zacke" )
predat     <- bimpre (dat=dat, GT=GT, simOpt=simOpt, deviation=0, minQuantity=0)
worth      <- bimworth(ydata    = predat,
GT       = GT,
simOpt   = simOpt,
randOP   = TRUE,
intrans  = TRUE,
showPlot = "worth")
worth
w_errors   <- bimeval(ydata=predat, worth= worth$worth, GT=GT, simOpt=simOpt, filtersim=TRUE )
w_errors
w_errors   <- bimeval(ydata=predat, worth= worth$worth, GT=GT, simOpt=simOpt, filtersim=FALSE )
w_errors
library(simsalRbim)
library(simsalRbim)
library(simsalRbim)
pkgdown::build_site()
library(simsalRbim)
pkgdown::build_site()
library(simsalRbim)
#  Perfect use case with no randomized items ------------------------------
dat        <- bimload("C:/MHH Bleich/Aktuelles/PrePrefPackage 2020/data/ZickeZackelinear.txt")
# dat <- dat[dat$subjectID=="eins", ]
simOpt     <- "Zicke"
GT         <- c("Zacke", "Huehner", "Kacke" )
predat     <- bimpre (dat=dat, GT=GT, simOpt=simOpt, deviation=0, minQuantity=0)
ydata    = predat
GT       = GT
simOpt   = simOpt
intrans  = TRUE
verbose  = TRU
verbose  = TRUE
showPlot = "worth"
# Decision Ratio (a quality estimatation)
Dratio = sum(ydata$result==1)/sum(ydata$result==-1)
# create the item list
optionList <- c(GT, simOpt)
# Randomize open pairs
if(randOP==TRUE){
nosim   <- ydata[ydata$sim==FALSE, ]
simdat  <- ydata[ydata$sim==TRUE,  ]
simdat$result  <- sample(c(0,1,-1), replace=TRUE, length(simdat$result))
ydata   <- rbind(nosim, simdat)
}else{}
randOP=FALSE
ylim=c(0,0.7)
verbose=FALSE
# create the item list
optionList <- c(GT, simOpt)
# Randomize open pairs
if(randOP==TRUE){
nosim   <- ydata[ydata$sim==FALSE, ]
simdat  <- ydata[ydata$sim==TRUE,  ]
simdat$result  <- sample(c(0,1,-1), replace=TRUE, length(simdat$result))
ydata   <- rbind(nosim, simdat)
}else{}
# calculate the intransitivity
if(intrans==TRUE){
I <- bimintrans(dat      = ydata,
idcolumn = "subjectID",
I2       = "optionB",
I1       = "optionA",
response = "result")
}else{}
### Do the model
modData    <- dcast(ydata, formula = subjectID ~ test,
fun.aggregate = sum, value.var = 'result')
modData$subjectID <- NULL
modelY     <- llbt.design(modData, nitems = length(optionList),
objnames = optionList   )
formula    <- as.formula(paste("y~",
paste( optionList[1:(length(optionList)-1) ] ,
collapse="+")) )
h1Y        <- gnm(formula, data = modelY, family = poisson  )
#NOTE: last entry of optionList is the intercept
library(prefmod)
library(gnm)
### Do the model
modData    <- dcast(ydata, formula = subjectID ~ test,
fun.aggregate = sum, value.var = 'result')
modData$subjectID <- NULL
modelY     <- llbt.design(modData, nitems = length(optionList),
objnames = optionList   )
formula    <- as.formula(paste("y~",
paste( optionList[1:(length(optionList)-1) ] ,
collapse="+")) )
h1Y        <- gnm(formula, data = modelY, family = poisson  )
#NOTE: last entry of optionList is the intercept
library(reshape2)
### Do the model
modData    <- dcast(ydata, formula = subjectID ~ test,
fun.aggregate = sum, value.var = 'result')
modData$subjectID <- NULL
modelY     <- llbt.design(modData, nitems = length(optionList),
objnames = optionList   )
formula    <- as.formula(paste("y~",
paste( optionList[1:(length(optionList)-1) ] ,
collapse="+")) )
h1Y        <- gnm(formula, data = modelY, family = poisson  )
#NOTE: last entry of optionList is the intercept
h1 Y
h1Y
p <- ggplot(new_df, aes(x=item, y=estimate)) +
geom_point(size=2) +
geom_errorbar(aes(ymin=lwr, ymax=upr), width=.1 ) +
# ylim(mYlim) +
labs(title    = "Item comparisons (no simulation)",
subtitle  = "Model coefficients with 95% confidence intervals")   +
ylab("Estimate") +
xlab("") +
labs(colour="Item") +
theme_bw()
p <- p + coord_flip()
print(p)
# Show the model estimates with 95% CIs in a separate plot
if(showPlot=="coef"){
f <- function(d) {
fit <- do.call("gnm", list(formula, data = d, family = poisson ))
stats::confint(fit)
}
CI <- as.data.frame(f(as.data.frame(modelY)))
rownames(CI)[1] <- simOpt
#hworY           <- llbt.worth(h1Y, outmat ="est")
hworY           <- as.matrix(coef(h1Y))
colnames(hworY) <- "estimate"
row.names(hworY)[1] <- simOpt
new_df          <- cbind(hworY[row.names(CI), ], CI)
colnames(new_df)<- c("estimate","lwr","upr")
new_df$item     <- rownames(new_df)
new_df$item <- factor(new_df$item,
levels = new_df$item[order(new_df$estimate)])
if(verbose==TRUE){
print(new_df)
}else{}
p <- ggplot(new_df, aes(x=item, y=estimate)) +
geom_point(size=2) +
geom_errorbar(aes(ymin=lwr, ymax=upr), width=.1 ) +
# ylim(mYlim) +
labs(title    = "Item comparisons (no simulation)",
subtitle  = "Model coefficients with 95% confidence intervals")   +
ylab("Estimate") +
xlab("") +
labs(colour="Item") +
theme_bw()
p <- p + coord_flip()
print(p)
}else{ }
print(summary(h1Y))
hworY      <- llbt.worth(h1Y, outmat ="worth")
plot( hworY, ylim=ylim, ylab="Worth value")
hworY
ggplot(W, aes(x=rep(1,dim(hworY)[1]), y=hworY) ) +
geom_point(color="black", shape=21  ) +
geom_line()
library(ggplot2)
ggplot(W, aes(x=rep(1,dim(hworY)[1]), y=hworY) ) +
geom_point(color="black", shape=21  ) +
geom_line()
p <- ggplot(hworY, aes(x=rep(1,dim(hworY)[1]), y=hworY) ) +
geom_point(color="black", shape=21  ) +
geom_line()
hworY
ggplot(hworY, aes(x=rep(1,dim(hworY)[1]), y=worth) ) +
geom_point(color="black", shape=21  ) +
geom_line()
data.frame(hworY)
ggplot(data.frame(hworY), aes(x=rep(1,dim(hworY)[1]), y=worth) ) +
geom_point(color="black", shape=21  )
ggplot(data.frame(hworY), aes(x=rep(1,dim(hworY)[1]), y=worth) ) +
geom_point(color="black", shape=21  ) +
geom_line()
ggplot(data.frame(hworY), aes(x=rep(1,dim(hworY)[1]), y=worth) ) +
geom_point(color="black", shape=21, size=4  ) +
geom_line()
ggplot(data.frame(hworY), aes(x=rep(1,dim(hworY)[1]), y=worth) ) +
geom_point(color="black", shape=21, size=6  ) +
geom_line()
ggplot(data.frame(hworY), aes(x=rep(1,dim(hworY)[1]), y=worth) ) +
geom_point(color="black", shape=21, size=6, fill=row.names(hworY)  ) +
geom_line()
ggplot(data.frame(hworY), aes(x=rep(1,dim(hworY)[1]), y=worth) ) +
geom_point(color="black", shape=21, size=6, fill= factor(row.names(hworY))  ) +
geom_line()
worth
dim(hworY)
n = dim(hworY)[1]
cols = gg_color_hue(n)
ggplot(data.frame(hworY), aes(x=rep(1,dim(hworY)[1]), y=worth) ) +
geom_point(color="black", shape=21, size=6, fill= cols  ) +
geom_line()
n = dim(hworY)[1]
cols = gg_color_hue(n)
?gg_color_hue
gg_color_hue <- function(n) {
hues = seq(15, 375, length = n + 1)
hcl(h = hues, l = 65, c = 100)[1:n]
}
n = dim(hworY)[1]
cols = gg_color_hue(n)
p <- ggplot(data.frame(hworY), aes(x=rep(1,dim(hworY)[1]), y=worth) ) +
geom_point(color="black", shape=21, size=6, fill= cols  ) +
geom_line()
p
ggplot(data.frame(hworY), aes(x=rep(1,dim(hworY)[1]), y=worth) ) +
geom_line() +
geom_point(color="black", shape=21, size=6, fill= cols
